"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.attachConsoleLogs = exports.getLinkByTemplate = exports.getErrorFromFailedTest = exports.tellReporter = exports.isMochaAllHooks = exports.isMochaEachHooks = exports.isEmpty = exports.getTestStatus = void 0;
const process_1 = __importDefault(require("process"));
const strip_ansi_1 = __importDefault(require("strip-ansi"));
const compoundError_1 = __importDefault(require("./compoundError"));
const constants_1 = require("./constants");
/**
 * Get allure test status by TestStat object
 * @param test {Object} - TestStat object
 * @param config {Object} - wdio config object
 * @private
 */
const getTestStatus = (test, config) => {
    if (config && config.framework === 'jasmine') {
        return 'failed';
    }
    if (test.error) {
        if (test.error.message) {
            const message = test.error.message.trim().toLowerCase();
            return (message.startsWith('assertionerror') || message.includes('expect')) ? 'failed' : 'broken';
        }
        if (test.error.stack) {
            const stackTrace = test.error.stack.trim().toLowerCase();
            return (stackTrace.startsWith('assertionerror') || stackTrace.includes('expect')) ? 'failed' : 'broken';
        }
    }
    return 'broken';
};
exports.getTestStatus = getTestStatus;
/**
 * Check is object is empty
 * @param object {Object}
 * @private
 */
const isEmpty = (object) => !object || Object.keys(object).length === 0;
exports.isEmpty = isEmpty;
/**
 * Is mocha beforeEach / afterEach hook
 * @param title {String} - hook title
 * @returns {boolean}
 * @private
 */
const isMochaEachHooks = (title) => constants_1.mochaEachHooks.some(hook => title.includes(hook));
exports.isMochaEachHooks = isMochaEachHooks;
/**
 * Is mocha beforeAll / afterAll hook
 * @param title {String} - hook title
 * @returns {boolean}
 * @private
 */
const isMochaAllHooks = (title) => constants_1.mochaAllHooks.some(hook => title.includes(hook));
exports.isMochaAllHooks = isMochaAllHooks;
/**
 * Call reporter
 * @param {string} event  - event name
 * @param {Object} msg - event payload
 * @private
 */
const tellReporter = (event, msg = {}) => {
    // Node 14 typings does not accept string in process.emit, but allow string in process.on
    process_1.default.emit(event, msg);
};
exports.tellReporter = tellReporter;
/**
 * Properly format error from different test runners
 * @param {Object} test - TestStat object
 * @returns {Object} - error object
 * @private
 */
const getErrorFromFailedTest = (test) => {
    if (test.errors && Array.isArray(test.errors)) {
        for (let i = 0; i < test.errors.length; i += 1) {
            if (test.errors[i].message)
                test.errors[i].message = (0, strip_ansi_1.default)(test.errors[i].message);
            if (test.errors[i].stack)
                test.errors[i].stack = (0, strip_ansi_1.default)(test.errors[i].stack);
        }
        return test.errors.length === 1 ? test.errors[0] : new compoundError_1.default(...test.errors);
    }
    if (test.error) {
        if (test.error.message)
            test.error.message = (0, strip_ansi_1.default)(test.error.message);
        if (test.error.stack)
            test.error.stack = (0, strip_ansi_1.default)(test.error.stack);
    }
    return test.error;
};
exports.getErrorFromFailedTest = getErrorFromFailedTest;
/**
 * Substitute task id to link template
 * @param {string} template - link template
 * @param {string} id - task id
 * @returns {string} - link after substitution
 * @private
 */
const getLinkByTemplate = (template, id) => {
    if (typeof template !== 'string') {
        return id;
    }
    if (!template.includes(constants_1.linkPlaceholder)) {
        throw Error(`The link template "${template}" must contain ${constants_1.linkPlaceholder} substring.`);
    }
    return template.replace(constants_1.linkPlaceholder, id);
};
exports.getLinkByTemplate = getLinkByTemplate;
/**
 *
 * @param {string} logs - logs to be attached
 * @param {string} allure - allure report object
 * @private
 */
const attachConsoleLogs = (logs, allure) => {
    if (logs) {
        allure === null || allure === void 0 ? void 0 : allure.addAttachment('Console Logs', '<pre style="display: inline-block; background-color: #4d4d4d; color: white; padding: 20px; text-shadow: 1px 1px 0 #444; min-width: 100%; height: auto; min-height: 100%;">'
            + '.........Console Logs.........\n\n' + logs + '</pre>', 'text/html');
    }
};
exports.attachConsoleLogs = attachConsoleLogs;
